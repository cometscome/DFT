<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>第一原理計算高速チュートリアル · 物性実験家のための無料でできる第一原理計算入門</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">物性実験家のための無料でできる第一原理計算入門</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">物性実験家のための無料でできる第一原理計算入門</a></li><li><a class="tocitem" href="../../ASE/howtouse/">ASEでの第一原理計算入門</a></li><li><a class="tocitem" href="../../ASE/jupyter/">Jupyter notebookの使用</a></li><li class="is-active"><a class="tocitem" href>第一原理計算高速チュートリアル</a><ul class="internal"><li><a class="tocitem" href="#質問について"><span>質問について</span></a></li><li><a class="tocitem" href="#最初に行うこと"><span>最初に行うこと</span></a></li><li><a class="tocitem" href="#ASEのインストール"><span>ASEのインストール</span></a></li><li><a class="tocitem" href="#結晶構造の入手"><span>結晶構造の入手</span></a></li><li><a class="tocitem" href="#ASEでの第一原理計算"><span>ASEでの第一原理計算</span></a></li><li><a class="tocitem" href="#第一原理計算のテスト"><span>第一原理計算のテスト</span></a></li><li class="toplevel"><a class="tocitem" href="#Google-Colaboratoryを使って第一原理計算"><span>Google Colaboratoryを使って第一原理計算</span></a></li><li><a class="tocitem" href="#Quantum-Espressoのインストール"><span>Quantum Espressoのインストール</span></a></li><li><a class="tocitem" href="#ASEのインストール-2"><span>ASEのインストール</span></a></li><li><a class="tocitem" href="#第一原理計算のテスト-2"><span>第一原理計算のテスト</span></a></li><li><a class="tocitem" href="#計算の再開"><span>計算の再開</span></a></li><li class="toplevel"><a class="tocitem" href="#DOSの計算"><span>DOSの計算</span></a></li><li class="toplevel"><a class="tocitem" href="#部分DOSの計算"><span>部分DOSの計算</span></a></li></ul></li><li><a class="tocitem" href="../../QM/QM0/">Quantum Espresso</a></li><li><a class="tocitem" href="../../chapter1/ASE/">Atomic Simulation Environment (ASE)</a></li><li><a class="tocitem" href="../../chapter1/MateriApps/">MateriApps LIVE!のインストール</a></li><li><a class="tocitem" href="../../chapter1/VirturlBox/">Virtual Boxのインストール</a></li><li><a class="tocitem" href="../../samples/samples/">ASEによる計算例</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>第一原理計算高速チュートリアル</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>第一原理計算高速チュートリアル</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/cometscome/DFT/blob/master/docs/src/Fast/fast.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="第一原理計算高速チュートリアル"><a class="docs-heading-anchor" href="#第一原理計算高速チュートリアル">第一原理計算高速チュートリアル</a><a id="第一原理計算高速チュートリアル-1"></a><a class="docs-heading-anchor-permalink" href="#第一原理計算高速チュートリアル" title="Permalink"></a></h1><p>一つ一つは見ていくのは面倒！という人のために、このページにあることを実行すれば第一原理計算ができるようにしました。 順番にやってみてください。固体の第一原理計算をQuantum Espressoで実行することを念頭においています。 ここに書いたことはあとで項別にまとめる予定です。</p><h2 id="質問について"><a class="docs-heading-anchor" href="#質問について">質問について</a><a id="質問について-1"></a><a class="docs-heading-anchor-permalink" href="#質問について" title="Permalink"></a></h2><p>こちらの記事に関する質問は https://github.com/cometscome/DFT/issues にしていただけるとスムーズに回答できると思います。</p><h2 id="最初に行うこと"><a class="docs-heading-anchor" href="#最初に行うこと">最初に行うこと</a><a id="最初に行うこと-1"></a><a class="docs-heading-anchor-permalink" href="#最初に行うこと" title="Permalink"></a></h2><p><a href="../../chapter1/MateriApps/#MateriApps-LIVE!のインストール">MateriApps LIVE!のインストール</a> をみて、MateriApps LIVE!のインストールを終わらせてください。</p><h2 id="ASEのインストール"><a class="docs-heading-anchor" href="#ASEのインストール">ASEのインストール</a><a id="ASEのインストール-1"></a><a class="docs-heading-anchor-permalink" href="#ASEのインストール" title="Permalink"></a></h2><p>左下のツバメみたいなアイコンをクリックして、System ToolsからLXTerminalを選んでターミナルを出し、 以下のものを打ち込んでください。これは全て仮想マシン上で行われていますので、お使いのPCへの影響は全くありませんので安心してください。</p><h3 id="MateriApps-2.5以前"><a class="docs-heading-anchor" href="#MateriApps-2.5以前">MateriApps 2.5以前</a><a id="MateriApps-2.5以前-1"></a><a class="docs-heading-anchor-permalink" href="#MateriApps-2.5以前" title="Permalink"></a></h3><pre><code class="language-none">sudo curl -kL https://bootstrap.pypa.io/get-pip.py | sudo python3</code></pre><p>パスワードを聞かれますが、これはlive と打ち込んでください。 次に、</p><pre><code class="language-none">python3 -m pip install --upgrade --user ase</code></pre><p>と入れてください。</p><h3 id="以降"><a class="docs-heading-anchor" href="#以降">3以降</a><a id="以降-1"></a><a class="docs-heading-anchor-permalink" href="#以降" title="Permalink"></a></h3><p>MateriApps 3.0以降の場合には、上記の2行ではなく、</p><pre><code class="language-sh">pip3 install --upgrade --user ase</code></pre><p>でASEをインストールすることができます。</p><h3 id="Jupyter-Notebook"><a class="docs-heading-anchor" href="#Jupyter-Notebook">Jupyter Notebook</a><a id="Jupyter-Notebook-1"></a><a class="docs-heading-anchor-permalink" href="#Jupyter-Notebook" title="Permalink"></a></h3><p>次に <a href="../../ASE/jupyter/#Jupyter-Notebookの起動">Jupyter Notebookの起動</a> をみてJupyter notebookを起動してください。</p><h2 id="結晶構造の入手"><a class="docs-heading-anchor" href="#結晶構造の入手">結晶構造の入手</a><a id="結晶構造の入手-1"></a><a class="docs-heading-anchor-permalink" href="#結晶構造の入手" title="Permalink"></a></h2><p>左下のツバメメニューからWebブラウザFirefoxを起動し、Materials Project URL:https://materialsproject.org/ に移動してください。 ここには様々な固体の情報がデータベース化されています。 無料で利用できますので、googleアカウントをお持ちであれば簡単にログインできます。</p><h3 id="NaClの構造の入手"><a class="docs-heading-anchor" href="#NaClの構造の入手">NaClの構造の入手</a><a id="NaClの構造の入手-1"></a><a class="docs-heading-anchor-permalink" href="#NaClの構造の入手" title="Permalink"></a></h3><p>さて、NaClの構造を入手してみましょう。 周期表の表示があるので、そこでNaをクリックするか、あるいは検索窓にNa-Clなどと入れれば見つけることができます。 NaClのどれかをクリックして表示させます。 ここで、</p><p><img src="../download.png" alt="fig1"/></p><p>のCIFをクリックし、「Computed」を選んでみましょう。 これでDownloadsディレクトリにファイルがダウンロードされました。</p><h3 id="Vestaによる結晶構造の確認"><a class="docs-heading-anchor" href="#Vestaによる結晶構造の確認">Vestaによる結晶構造の確認</a><a id="Vestaによる結晶構造の確認-1"></a><a class="docs-heading-anchor-permalink" href="#Vestaによる結晶構造の確認" title="Permalink"></a></h3><p>次に、ターミナルに戻ります。 ここで、</p><pre><code class="language-none"> cd ~/Downloads/</code></pre><p>でDownloadsディレクトリに移動すると、ファイルがあるのがわかると思います。 そして、</p><pre><code class="language-none">vesta NaCl_mp-22862_computed.cif</code></pre><p>とすればVESTAが立ち上がり、結晶構造を見ることができます。 VESTAは非常に優秀な「結晶構造、電子・核密度等の三次元データ、及び結晶外形の可視化プログラム」です。 https://jp-minerals.org/vesta/jp/</p><h2 id="ASEでの第一原理計算"><a class="docs-heading-anchor" href="#ASEでの第一原理計算">ASEでの第一原理計算</a><a id="ASEでの第一原理計算-1"></a><a class="docs-heading-anchor-permalink" href="#ASEでの第一原理計算" title="Permalink"></a></h2><h3 id="ASEでの取り込み"><a class="docs-heading-anchor" href="#ASEでの取り込み">ASEでの取り込み</a><a id="ASEでの取り込み-1"></a><a class="docs-heading-anchor-permalink" href="#ASEでの取り込み" title="Permalink"></a></h3><p>保存したファイルをjupyter notebookでASEを使って取り扱ってみましょう。 保存したファイルは</p><pre><code class="language-none">cp ~/Downloads/NaCl_mp-22862_computed.cif ~/ASE/</code></pre><p>で作ったフォルダにコピーしておきましょう。 あとは</p><pre><code class="language-none">import ase.io 
rocksalt =ase.io.read(&quot;NaCl_mp-22862_computed.cif&quot;)</code></pre><p>すれば読み込むことができます。</p><h3 id="第一原理計算のテスト実行"><a class="docs-heading-anchor" href="#第一原理計算のテスト実行">第一原理計算のテスト実行</a><a id="第一原理計算のテスト実行-1"></a><a class="docs-heading-anchor-permalink" href="#第一原理計算のテスト実行" title="Permalink"></a></h3><p>このあとは、</p><p><a href="../../samples/samples/#NaCl結晶の格子定数">NaCl結晶の格子定数</a> のようにやればよいです。</p><p>具体的には、ターミナルでまず</p><p>擬ポテンシャルのダウンロード：</p><pre><code class="language-bash">cd /usr/share/espresso/pseudo
sudo wget https://www.quantum-espresso.org/upf_files/Na.pbesol-spn-kjpaw_psl.1.0.0.UPF
sudo wget https://www.quantum-espresso.org/upf_files/Cl.pbesol-n-kjpaw_psl.1.0.0.UPF</code></pre><p>NaとClの擬ポテンシャルをダウンロードします。なお、他の擬ポテンシャルは https://www.quantum-espresso.org/pseudopotentials にあります。</p><p>次に、Jupyter notebook上で</p><pre><code class="language-python">from ase.build import bulk
from ase.calculators.espresso import Espresso
from ase.constraints import UnitCellFilter
from ase.optimize import LBFGS
import ase.io 

#pseudopotentials = {&#39;Na&#39;: &#39;Na.pbe-spn-kjpaw_psl.1.0.0.UPF&#39;,
#                    &#39;Cl&#39;: &#39;Cl.pbe-n-rrkjus_psl.1.0.0.UPF&#39;} #擬ポテンシャルの種類が違うの修正
pseudopotentials = {&#39;Na&#39;: &#39;Na.pbesol-spn-kjpaw_psl.1.0.0.UPF&#39;,
                    &#39;Cl&#39;: &#39;Cl.pbesol-n-kjpaw_psl.1.0.0.UPF&#39;}
#rocksalt = bulk(&#39;NaCl&#39;, crystalstructure=&#39;rocksalt&#39;, a=6.0)
rocksalt =ase.io.read(&quot;NaCl_mp-22862_computed.cif&quot;) #Material Projectでダウンロードしたものを使う場合。
calc = Espresso(pseudopotentials=pseudopotentials,
                tstress=True, tprnfor=True, kpts=(3, 3, 3))

rocksalt.set_calculator(calc)

ucf = UnitCellFilter(rocksalt)
opt = LBFGS(ucf)
opt.run(fmax=0.005)

# cubic lattic constant
print((8*rocksalt.get_volume()/len(rocksalt))**(1.0/3.0))</code></pre><p>コードでは、格子定数を最初は6として、設定したあと、構造最適化をしています。最後に、構造最適化して出てきた格子定数をプリントしています。</p><p>これを実行すると、</p><pre><code class="language-none">       Step     Time          Energy         fmax
LBFGS:    0 21:27:48    -1960.836397        0.0625
LBFGS:    1 21:28:01    -1960.836540        0.0501
LBFGS:    2 21:28:13    -1960.834692        0.0338
LBFGS:    3 21:28:26    -1960.833702        0.0079
LBFGS:    4 21:28:39    -1960.834037        0.0006
5.661404166984403</code></pre><p>と出ます。 これで第一原理計算でNaClの構造最適化ができました。</p><h2 id="第一原理計算のテスト"><a class="docs-heading-anchor" href="#第一原理計算のテスト">第一原理計算のテスト</a><a id="第一原理計算のテスト-1"></a><a class="docs-heading-anchor-permalink" href="#第一原理計算のテスト" title="Permalink"></a></h2><h3 id="Siのバンド構造"><a class="docs-heading-anchor" href="#Siのバンド構造">Siのバンド構造</a><a id="Siのバンド構造-1"></a><a class="docs-heading-anchor-permalink" href="#Siのバンド構造" title="Permalink"></a></h3><p>Siのバンド計算をやってみましょう。 まず、バルクのSiを用意し、計算としてQuantum Espressoを使うことにします。</p><pre><code class="language-python">from ase.build import bulk
from ase.calculators.espresso import Espresso
atoms = bulk(&quot;Si&quot;) #バルクのSiの用意
pseudopotentials = {&#39;Si&#39;:&#39;Si.pz-vbc.UPF&#39;} #擬ポテンシャルの設定


input_data = {
    &#39;system&#39;: {
        &#39;ecutwfc&#39;: 64,
        &#39;ecutrho&#39;: 576,
        &#39;nbnd&#39; : 12 },
    &#39;disk_io&#39;: &#39;low&#39;}  #Quantum Espressoのパラメータ

calc = Espresso(pseudopotentials=pseudopotentials,kpts=(4, 4, 4),input_data=input_data)
atoms.set_calculator(calc)</code></pre><p>Quantum Espressoのパラメータを<code>input_data</code>で入れることができます。 詳しくは http://www.stat.phys.titech.ac.jp/SATL<em>qe</em>tutorial/index.html が参考になると思います。</p><p>ここのcalcを別のものにすると、別の第一原理計算ソフトを使うことができます。 原子配置が与えられた時にエネルギーが返ってくればいいので、第一原理計算である必要もありません。 詳しくは https://wiki.fysik.dtu.dk/ase/ase/calculators/calculators.html を見てみてください。</p><p>次に、自己無撞着計算をして、電子密度を決定します。電子密度が決定されれば、各k点での計算をすることでバンド図を 描くことができます。</p><pre><code class="language-python">atoms.get_potential_energy()
fermi_level = calc.get_fermi_level()
print(fermi_level)</code></pre><p>次に、バンド図用のバンド計算を行います。</p><pre><code class="language-python">input_data.update({&#39;calculation&#39;:&#39;bands&#39;,
                              &#39;restart_mode&#39;:&#39;restart&#39;,
                               &#39;verbosity&#39;:&#39;high&#39;})
calc.set(kpts={&#39;path&#39;:&#39;LGXWG&#39;, &#39;npoints&#39;:100},
          input_data=input_data)
calc.calculate(atoms)</code></pre><p>となります。ここで、kptsのpathに好きなブリルアンゾーンの点を入れることで、簡単にバンド図を描くことができるのがASEの面白い点です。 L点、Gamma点、X点、W点、Gamma点の順番にバンドを描きます。</p><p>計算が終わったら、図をプロットしましょう。</p><pre><code class="language-python">import matplotlib.pyplot as plt

bs = calc.band_structure()
bs.reference = fermi_level

bs.plot(emax=15, filename=&#39;Si.png&#39;)</code></pre><p>でできます。</p><p>得られた図は</p><p><img src="../Si.png" alt="fig2"/></p><p>となります。よくみるSiのバンド図になっていますね。</p><h3 id="金属の計算：Cuのバンド図"><a class="docs-heading-anchor" href="#金属の計算：Cuのバンド図">金属の計算：Cuのバンド図</a><a id="金属の計算：Cuのバンド図-1"></a><a class="docs-heading-anchor-permalink" href="#金属の計算：Cuのバンド図" title="Permalink"></a></h3><p>Cuのバンド計算をやってみましょう。 まず、最初のSCF計算は</p><pre><code class="language-python">from ase import Atoms
from ase.build import bulk
from ase.calculators.espresso import Espresso
atoms = bulk(&quot;Cu&quot;)
pseudopotentials = {&#39;Cu&#39;:&#39;Cu.pz-d-rrkjus.UPF&#39;}

input_data = {
    &#39;system&#39;: {
        &#39;ecutwfc&#39;: 30,
        &#39;ecutrho&#39;: 240,
        &#39;nbnd&#39; : 35,
    &#39;occupations&#39; : &#39;smearing&#39;,
        &#39;smearing&#39;:&#39;gauss&#39;,
        &#39;degauss&#39; : 0.01},
    &#39;disk_io&#39;: &#39;low&#39;}  # automatically put into &#39;control&#39;

calc = Espresso(pseudopotentials=pseudopotentials,kpts=(4, 4, 4),input_data=input_data)
atoms.set_calculator(calc)

atoms.get_potential_energy()
fermi_level = calc.get_fermi_level()
print(fermi_level)</code></pre><p>となります。Siの時との違いはoccupationsがsmearingになっているなどですね。どうやら金属ではこの設定が重要だそうです。 <code>input_data</code>にはQuantum Espressoのパラメータが入りますが、ここは経験的なものが必要かもしれません。 とりあえず様々なチュートリアルをみると良いと思います。 例えば、 <a href="http://www.cmpt.phys.tohoku.ac.jp/~koretsune/SATL_qe_tutorial/index.html">quantum ESPRESSO tutorial</a> はとても良い資料だと思います。</p><p>次に、バンド計算は</p><pre><code class="language-python">input_data.update({&#39;calculation&#39;:&#39;bands&#39;,
                              &#39;restart_mode&#39;:&#39;restart&#39;,
                               &#39;verbosity&#39;:&#39;high&#39;})
calc.set(kpts={&#39;path&#39;:&#39;GXWLGK&#39;, &#39;npoints&#39;:100},
          input_data=input_data)
calc.calculate(atoms)</code></pre><p>でできます。Siの時と同じですね。</p><p>そして、バンド図は</p><pre><code class="language-python">import matplotlib.pyplot as plt

bs = calc.band_structure()
bs.reference = fermi_level
bs.plot(emax=40,emin=5,filename=&#39;Cu.png&#39;)</code></pre><p>となります。 バンド図は</p><p><img src="../Cu.png" alt="fig3"/></p><p>となります。</p><h3 id="金属の計算：Cuのフェルミ面"><a class="docs-heading-anchor" href="#金属の計算：Cuのフェルミ面">金属の計算：Cuのフェルミ面</a><a id="金属の計算：Cuのフェルミ面-1"></a><a class="docs-heading-anchor-permalink" href="#金属の計算：Cuのフェルミ面" title="Permalink"></a></h3><p>次にCuのフェルミ面を出してみましょう。<a href="http://fermisurfer.osdn.jp/en/_build/html/qe.html">Fermisurfer</a>を使います。 まず、フェルミ面を書くための計算をします。</p><pre><code class="language-python">from ase import Atoms
from ase.build import bulk
from ase.calculators.espresso import Espresso
atoms = bulk(&quot;Cu&quot;)
pseudopotentials = {&#39;Cu&#39;:&#39;Cu.pz-d-rrkjus.UPF&#39;}

input_data = {
    &#39;system&#39;: {
        &#39;ecutwfc&#39;: 30,
        &#39;ecutrho&#39;: 240,
        &#39;nbnd&#39; : 35,
    &#39;occupations&#39; : &#39;smearing&#39;,
        &#39;smearing&#39;:&#39;gauss&#39;,
        &#39;degauss&#39; : 0.01},
    &#39;CONTROL&#39;:{
 &#39;calculation&#39;:&#39;scf&#39;,
      &#39;prefix&#39;:&#39;Cu&#39; ,
      &#39;outdir&#39;:&#39;./&#39;},
    &#39;disk_io&#39;: &#39;low&#39;}  # automatically put into &#39;control&#39;

calc = Espresso(pseudopotentials=pseudopotentials,kpts=(8, 8, 8),input_data=input_data)
atoms.set_calculator(calc)

atoms.get_potential_energy()
fermi_level = calc.get_fermi_level()
print(fermi_level)</code></pre><p>先ほどとほとんど同じです。ここで、<code>kpts=(8, 8, 8)</code>となっていますが、これがk点の数で、これが大きいほどフェルミ面が詳細に描けます。 ただし、計算は重くなっていきます。</p><p>これを実行したあと、フェルミ速度などを計算するコードを実行します。</p><pre><code class="language-none">!fermi_velocity.x  -in espresso.pwi</code></pre><p>ここで、<code>!</code>マークはPythonではなく通常の実行をする意味です。ですので。普通のターミナルからも実行できます。 なお、ASEではespressoのインプットファイルは自動的に作成され、名前は<code>espresso.pwi</code>です。</p><p>そして、</p><pre><code class="language-none">!fermisurfer vfermi.frmsf</code></pre><p>とすると、fermisurferが立ち上がります。</p><p><img src="../FermiCu.png" alt="fig4"/> 銅のよくあるフェルミ面が出てきましたでしょうか？</p><h3 id="スピン軌道相互作用の考慮：SnTeのバンド計算"><a class="docs-heading-anchor" href="#スピン軌道相互作用の考慮：SnTeのバンド計算">スピン軌道相互作用の考慮：SnTeのバンド計算</a><a id="スピン軌道相互作用の考慮：SnTeのバンド計算-1"></a><a class="docs-heading-anchor-permalink" href="#スピン軌道相互作用の考慮：SnTeのバンド計算" title="Permalink"></a></h3><p>次は、スピン軌道相互作用を入れてみましょう。 対象の物質としては、SnTeを考えます。この物質はSnをPbに少し置換すると、トポロジカル結晶絶縁体、というものになることが知られています。 <a href="https://www.nature.com/articles/ncomms1969">Topological crystalline insulators in the SnTe material class</a> トポロジカル物質は大抵の場合スピン軌道相互作用が非常に重要でして、スピン軌道相互作用を考慮する計算をやることにします。</p><p>まず、結晶のデータを<a href="https://materialsproject.org/materials/mp-1883/">Materials Project</a> から取ってくることにします。ここで、前と同じようにcifデータをダウンロードしてください。 このページにはスピン軌道相互作用のない場合のバンド図もありますので、まず、このバンド図と同じ図を出すことにします。</p><p>ということで、スピン軌道相互作用なしのバンド図を描いてみます。 擬ポテンシャルをダウンロードします。ここで、SnとTeで同じタイプのものを選んでください。 この辺りが参考になると思います（<a href="http://www.stat.phys.titech.ac.jp/SATL_qe_tutorial/new_material.html">物質のインプットファイルを新たに作成する</a>）。 具体的には、<code>Pseudopotential type: USPP</code>とします。これはウルトラソフト型です。とりあえずこれを選んでおけば大丈夫でしょう（多分。詳しい人むしろ教えてください）。 交換相関汎関数も揃えてください。 ここでは、SnとTeで</p><pre><code class="language-none">!wget https://www.quantum-espresso.org/upf_files/Sn.pbesol-dn-rrkjus_psl.0.2.UPF
!wget https://www.quantum-espresso.org/upf_files/Te.pbesol-dn-rrkjus_psl.0.2.2.UPF</code></pre><p>の二つをダウンロードしました。これはJupyter notebookで実行しているため!がついています。 ここで、スピン軌道相互作用を考慮しないので、「Scalar relativistic」を用いています。</p><p>これをNaClの時のように計算します。つまり、自己無撞着に電子密度を決定します。</p><pre><code class="language-python">from ase.build import bulk
from ase.calculators.espresso import Espresso
from ase.constraints import UnitCellFilter
import ase.io 

pseudopotentials = {&#39;Sn&#39;: &#39;Sn.pbesol-dn-rrkjus_psl.0.2.UPF&#39;,
                    &#39;Te&#39;: &#39;Te.pbesol-dn-rrkjus_psl.0.2.2.UPF&#39;}
atoms =ase.io.read(&quot;SnTe_mp-1883_computed.cif&quot;)

input_data = {
    &#39;system&#39;: {
        &#39;ecutwfc&#39;: 30,
        &#39;ecutrho&#39;: 240,
        &#39;nbnd&#39; : 35,
    &#39;occupations&#39; : &#39;smearing&#39;,
        &#39;smearing&#39;:&#39;gauss&#39;,
        &#39;degauss&#39; : 0.01},
    &#39;CONTROL&#39;:{
 &#39;calculation&#39;:&#39;scf&#39;,
      &#39;prefix&#39;:&#39;SnTe&#39; ,
      &#39;outdir&#39;:&#39;./&#39;,
    &#39;pseudo_dir&#39;:&#39;./&#39;},
    &#39;disk_io&#39;: &#39;low&#39;} 

calc = Espresso(pseudopotentials=pseudopotentials,kpts=(4, 4, 4),input_data=input_data)
atoms.set_calculator(calc)


atoms.get_potential_energy()
fermi_level = calc.get_fermi_level()
print(fermi_level)</code></pre><p>とします。ここで、<code>pseudo_dir</code>を設定していますが、これは、計算するディレクトリを指定しており、そこの擬ポテンシャルを使うためです。 計算を実行後、バンド図用の計算を行います。</p><pre><code class="language-python">input_data.update({&#39;calculation&#39;:&#39;bands&#39;,
                              &#39;restart_mode&#39;:&#39;restart&#39;,
                               &#39;verbosity&#39;:&#39;high&#39;})
calc.set(kpts={&#39;path&#39;:&#39;GLUWLU&#39;, &#39;npoints&#39;:100},
          input_data=input_data)
calc.calculate(atoms)</code></pre><p>そして、図を</p><pre><code class="language-python">import matplotlib.pyplot as plt

bs = calc.band_structure()
bs.reference = fermi_level

bs.plot(emax=13,emin=4,filename=&#39;SnTe.png&#39;)
bs.plot(emax=fermi_level+2,emin=fermi_level-2,filename=&#39;SnTe_mag.png&#39;)</code></pre><p>とプロットします。ここでは二つプロットしました。</p><p>結果は、</p><p><img src="../SnTe.png" alt="figSnTe1"/> <img src="../SnTe_mag.png" alt="figSnTe2"/></p><p>となります。</p><p>次に、スピン軌道相互作用を入れてみましょう。 擬ポテンシャルをスピン軌道相互作用対応にしなければなりません。そこで、</p><pre><code class="language-none">!wget https://www.quantum-espresso.org/upf_files/Sn.rel-pbesol-dn-rrkjus_psl.0.2.UPF
!wget https://www.quantum-espresso.org/upf_files/Te.rel-pbesol-dn-rrkjus_psl.0.2.2.UPF</code></pre><p>をダウンロードしてきます。これらは、<code>Full relativistic</code>と書いてあるものです。</p><p>そして、</p><pre><code class="language-python">from ase.build import bulk
from ase.calculators.espresso import Espresso
from ase.constraints import UnitCellFilter
import ase.io 
pseudopotentials = {&#39;Sn&#39;: &#39;Sn.rel-pbesol-dn-rrkjus_psl.0.2.UPF&#39;,
                    &#39;Te&#39;: &#39;Te.rel-pbesol-dn-rrkjus_psl.0.2.2.UPF&#39;}

atoms =ase.io.read(&quot;SnTe_mp-1883_computed.cif&quot;)

input_data = {
    &#39;system&#39;: {
        &#39;ecutwfc&#39;: 30,
        &#39;ecutrho&#39;: 240,
        &#39;nbnd&#39; : 35,
    &#39;occupations&#39; : &#39;smearing&#39;,
        &#39;smearing&#39;:&#39;gauss&#39;,
        &#39;degauss&#39; : 0.01,
    &#39;noncolin&#39;: True,
    &#39;lspinorb&#39;: True},
    &#39;CONTROL&#39;:{
 &#39;calculation&#39;:&#39;scf&#39;,
      &#39;prefix&#39;:&#39;SnTe&#39; ,
      &#39;outdir&#39;:&#39;./&#39;,
    &#39;pseudo_dir&#39;:&#39;./&#39;},
    &#39;disk_io&#39;: &#39;low&#39;} 

calc = Espresso(pseudopotentials=pseudopotentials,kpts=(4, 4, 4),input_data=input_data)
atoms.set_calculator(calc)


atoms.get_potential_energy()
fermi_level = calc.get_fermi_level()
print(fermi_level)</code></pre><p>が自己無撞着計算のコードです。ここで、スピン軌道相互作用を計算する際には<code>noncolin</code>と<code>lspinorb</code>をTrueにする必要があります。 <a href="https://www.quantum-espresso.org/Doc/pw_user_guide/node10.html">Noncollinear magnetization, spin-orbit interactions</a></p><p>そして、バンド図は</p><pre><code class="language-python">input_data.update({&#39;calculation&#39;:&#39;bands&#39;,
                              &#39;restart_mode&#39;:&#39;restart&#39;,
                               &#39;verbosity&#39;:&#39;high&#39;})
calc.set(kpts={&#39;path&#39;:&#39;GLUWLU&#39;, &#39;npoints&#39;:100},
          input_data=input_data)
calc.calculate(atoms)</code></pre><p>で計算でき、プロットは</p><pre><code class="language-python">import matplotlib.pyplot as plt

bs = calc.band_structure()
bs.reference = fermi_level

bs.plot(emax=13,emin=4,filename=&#39;SnTe_SO.png&#39;)
bs.plot(emax=fermi_level+2,emin=fermi_level-2,filename=&#39;SnTe_mag_SO.png&#39;)</code></pre><p>でできます。</p><p>得られた図は</p><p><img src="../SnTe_SO.png" alt="figSnTe1_SO"/> <img src="../SnTe_SO_mag.png" alt="figSnTe2_SO"/></p><p>となります。スピン軌道相互作用によってギャップが開いていることと、フェルミレベルから数えて２本目のバンドのスピン縮退が解けていることがわかります。 他の文献を比べてみましょう。</p><h1 id="Google-Colaboratoryを使って第一原理計算"><a class="docs-heading-anchor" href="#Google-Colaboratoryを使って第一原理計算">Google Colaboratoryを使って第一原理計算</a><a id="Google-Colaboratoryを使って第一原理計算-1"></a><a class="docs-heading-anchor-permalink" href="#Google-Colaboratoryを使って第一原理計算" title="Permalink"></a></h1><p>これまではMateriapps live!を使って計算していましたが、Google Colaboratoryを使った方法がわかりましたので、そちらも記します。 Google Colaboratoryはブラウザ上でGoogleの計算機上で計算を実行することができます。 GoogleのアカウントがあればすぐにPythonの実行環境が手に入ります。機械学習で使うライブラリがデフォルトで入っていて、環境構築が不要で人気です。 このGoogle ColabにQunatum Espressoを入れて第一原理計算をしてみましょう。</p><h2 id="Quantum-Espressoのインストール"><a class="docs-heading-anchor" href="#Quantum-Espressoのインストール">Quantum Espressoのインストール</a><a id="Quantum-Espressoのインストール-1"></a><a class="docs-heading-anchor-permalink" href="#Quantum-Espressoのインストール" title="Permalink"></a></h2><p>そのためにはQunatum Espressoをソースからコンパイルする必要がありますが、以下のような方法で可能であることがわかりました。 ポイントは、FFTW3をインストールしておくことです。</p><pre><code class="language-none">!git clone https://github.com/QEF/q-e.git
!apt-get install -y libfftw3-3 libfftw3-dev libfftw3-doc
%cd q-e
!DFLAGS=&#39;-D__OPENMP -D__FFTW3 -D__MPI -D__SCALAPACK&#39; FFT_LIBS=&#39;-lfftw3&#39;  ./configure --enable-openmp</code></pre><p>ソースをダウンロードし、FFTW3をインストール、そしてコンパイル準備をしています。 次に、</p><pre><code class="language-none">!make pw</code></pre><p>でQuantum Espressoのコアのコードであるpw.xを実行できます。 あとはポストプロセスツールである、pp:</p><pre><code class="language-none">make pp</code></pre><p>もインストールしておきましょう。</p><p>さて、<a href="https://qiita.com/kuronekodaisuki/items/d7910259120ef805f686">Google colaboratoryでOSSをビルドする</a> にありますように、ここでコンパイルしたバイナリは12時間後に消滅してしまいます。 ですので、</p><pre><code class="language-none">from google.colab import drive
drive.mount(&#39;/content/drive&#39;)</code></pre><p>を実行してご自分のGoogle Driveにバイナリを保存しておきましょう。次に使うときはこれを解凍して使います。</p><pre><code class="language-none">%cd /content/
!zip -r /content/drive/&#39;My Drive&#39;/q-e.zip q-e </code></pre><p>としてq-e.zipを保存しておきます。</p><p>Quantum Espressoを実行できるように、環境変数を設定します。つまり、</p><pre><code class="language-none">import os
os.environ[&#39;PATH&#39;] = &quot;/content/q-e/bin:&quot;+os.environ[&#39;PATH&#39;]</code></pre><p>とします。</p><h2 id="ASEのインストール-2"><a class="docs-heading-anchor" href="#ASEのインストール-2">ASEのインストール</a><a class="docs-heading-anchor-permalink" href="#ASEのインストール-2" title="Permalink"></a></h2><p>ASEのインストールは簡単で、</p><pre><code class="language-none">!pip install ase</code></pre><p>で入ります。</p><h2 id="第一原理計算のテスト-2"><a class="docs-heading-anchor" href="#第一原理計算のテスト-2">第一原理計算のテスト</a><a class="docs-heading-anchor-permalink" href="#第一原理計算のテスト-2" title="Permalink"></a></h2><p>上でやっていた第一原理計算をこちらでもやってみましょう。</p><h3 id="NaClの構造最適化"><a class="docs-heading-anchor" href="#NaClの構造最適化">NaClの構造最適化</a><a id="NaClの構造最適化-1"></a><a class="docs-heading-anchor-permalink" href="#NaClの構造最適化" title="Permalink"></a></h3><p>NaClのディレクトリを作成し、移動します。</p><pre><code class="language-none">%cd /content
!mkdir NaCl
%cd NaCl</code></pre><p>そして、擬ポテンシャルをダウンロードします。</p><pre><code class="language-none">!wget https://www.quantum-espresso.org/upf_files/Na.pbesol-spn-kjpaw_psl.1.0.0.UPF
!wget https://www.quantum-espresso.org/upf_files/Cl.pbesol-n-kjpaw_psl.1.0.0.UPF</code></pre><p>これはNaClディレクトリに入りました。</p><p>次に、</p><pre><code class="language-python">from ase.build import bulk
from ase.calculators.espresso import Espresso
from ase.constraints import UnitCellFilter
from ase.optimize import LBFGS
import ase.io 

#pseudopotentials = {&#39;Na&#39;: &#39;Na.pbe-spn-kjpaw_psl.1.0.0.UPF&#39;,
#                    &#39;Cl&#39;: &#39;Cl.pbe-n-rrkjus_psl.1.0.0.UPF&#39;} #擬ポテンシャルの種類が違うの修正
pseudopotentials = {&#39;Na&#39;: &#39;Na.pbesol-spn-kjpaw_psl.1.0.0.UPF&#39;,
                    &#39;Cl&#39;: &#39;Cl.pbesol-n-kjpaw_psl.1.0.0.UPF&#39;}                    
rocksalt = bulk(&#39;NaCl&#39;, crystalstructure=&#39;rocksalt&#39;, a=6.0)
calc = Espresso(pseudopotentials=pseudopotentials,pseudo_dir = &#39;./&#39;,
                tstress=True, tprnfor=True, kpts=(3, 3, 3))

rocksalt.set_calculator(calc)

ucf = UnitCellFilter(rocksalt)
opt = LBFGS(ucf)
opt.run(fmax=0.005)

# cubic lattic constant
print((8*rocksalt.get_volume()/len(rocksalt))**(1.0/3.0))</code></pre><p>を実行すれば、NaClの構造最適化ができます。このコードでは擬ポテンシャルの場所を<code>pseudo_dir</code>で指定しています。今回は今いるディレクトリですね。</p><h3 id="Cuのバンド図"><a class="docs-heading-anchor" href="#Cuのバンド図">Cuのバンド図</a><a id="Cuのバンド図-1"></a><a class="docs-heading-anchor-permalink" href="#Cuのバンド図" title="Permalink"></a></h3><p>次に、Cuのバンド図を計算してみます。</p><p>Cuのディレクトリを作成します。</p><pre><code class="language-none">%cd /content
!mkdir Cu
%cd Cu</code></pre><p>擬ポテンシャルをダウンロードします。</p><pre><code class="language-none">!wget https://www.quantum-espresso.org/upf_files/Cu.pz-d-rrkjus.UPF</code></pre><p>そして、まず自己無撞着計算をします。</p><pre><code class="language-python">from ase import Atoms
from ase.build import bulk
from ase.calculators.espresso import Espresso
atoms = bulk(&quot;Cu&quot;)
pseudopotentials = {&#39;Cu&#39;:&#39;Cu.pz-d-rrkjus.UPF&#39;}

input_data = {
    &#39;system&#39;: {
        &#39;ecutwfc&#39;: 30,
        &#39;ecutrho&#39;: 240,
        &#39;nbnd&#39; : 35,
    &#39;occupations&#39; : &#39;smearing&#39;,
        &#39;smearing&#39;:&#39;gauss&#39;,
        &#39;degauss&#39; : 0.01},
    &#39;disk_io&#39;: &#39;low&#39;}  # automatically put into &#39;control&#39;

calc = Espresso(pseudopotentials=pseudopotentials,kpts=(4, 4, 4),input_data=input_data,pseudo_dir = &#39;./&#39;)
atoms.set_calculator(calc)

atoms.get_potential_energy()
fermi_level = calc.get_fermi_level()
print(fermi_level)</code></pre><p>そして、バンド図のための計算をします。</p><pre><code class="language-python">input_data.update({&#39;calculation&#39;:&#39;bands&#39;,
                              &#39;restart_mode&#39;:&#39;restart&#39;,
                               &#39;verbosity&#39;:&#39;high&#39;})
calc.set(kpts={&#39;path&#39;:&#39;GXWLGK&#39;, &#39;npoints&#39;:100},
          input_data=input_data)
calc.calculate(atoms)</code></pre><p>最後にバンド図を計算します。</p><pre><code class="language-python">import matplotlib.pyplot as plt

bs = calc.band_structure()
bs.reference = fermi_level
bs.plot(emax=40,emin=5)</code></pre><p>これで、ブラウザだけで第一原理計算を実行できるようになりました。</p><h2 id="計算の再開"><a class="docs-heading-anchor" href="#計算の再開">計算の再開</a><a id="計算の再開-1"></a><a class="docs-heading-anchor-permalink" href="#計算の再開" title="Permalink"></a></h2><p>別に日に計算を再開したい場合は、以下のようにやるとできると思います。</p><pre><code class="language-python">from google.colab import drive
drive.mount(&#39;/content/drive&#39;)
!cp /content/drive/&#39;My Drive&#39;/q-e.zip ./
!unzip q-e.zip
import os
os.environ[&#39;PATH&#39;] = &quot;/content/q-e/bin:&quot;+os.environ[&#39;PATH&#39;]
!pip install ase</code></pre><p>あとは、ディレクトリを作って、そこに擬ポテンシャルをダウンロードしたりすればよいでしょう。</p><pre><code class="language-python">!mkdir NaCl
%cd NaCl
!wget https://www.quantum-espresso.org/upf_files/Na.pbe-spn-kjpaw_psl.1.0.0.UPF
!wget https://www.quantum-espresso.org/upf_files/Cl.pbe-n-rrkjus_psl.1.0.0.UPF</code></pre><h1 id="DOSの計算"><a class="docs-heading-anchor" href="#DOSの計算">DOSの計算</a><a id="DOSの計算-1"></a><a class="docs-heading-anchor-permalink" href="#DOSの計算" title="Permalink"></a></h1><p>状態密度の計算をしてみましょう。ここではColabを使います。</p><p>まず擬ポテンシャルをダウンロードしておきます。</p><pre><code class="language-python">!mkdir Si
!cd Si
!wget https://www.quantum-espresso.org/upf_files/Si.pz-vbc.UPF</code></pre><p>次に、最初のSCF計算をします。</p><pre><code class="language-python">from ase.build import bulk
from ase.calculators.espresso import Espresso
atoms = bulk(&quot;Si&quot;) #バルクのSiの用意
pseudopotentials = {&#39;Si&#39;:&#39;Si.pz-vbc.UPF&#39;} #擬ポテンシャルの設定


input_data = {
    &#39;system&#39;: {
        &#39;ecutwfc&#39;: 64,
        &#39;ecutrho&#39;: 576,
        &#39;nbnd&#39; : 12 },
    &#39;disk_io&#39;: &#39;low&#39;}  #Quantum Espressoのパラメータ

calc = Espresso(pseudopotentials=pseudopotentials,pseudo_dir = &#39;./&#39;,kpts=(4, 4, 4),input_data=input_data)
atoms.set_calculator(calc)
atoms.get_potential_energy()
fermi_level = calc.get_fermi_level()
print(fermi_level)</code></pre><p>バンド図もついでに描いておきましょう。</p><pre><code class="language-python">input_data.update({&#39;calculation&#39;:&#39;bands&#39;,
                              &#39;restart_mode&#39;:&#39;restart&#39;,
                               &#39;verbosity&#39;:&#39;high&#39;})
calc.set(kpts={&#39;path&#39;:&#39;LGXWG&#39;, &#39;npoints&#39;:100},
          input_data=input_data)
calc.calculate(atoms)</code></pre><pre><code class="language-python">import matplotlib.pyplot as plt

bs = calc.band_structure()
bs.reference = fermi_level

bs.plot(emax=15, filename=&#39;Si.png&#39;)</code></pre><p>次に、DOS用の計算をします。これは、</p><pre><code class="language-python">input_data.update({&#39;calculation&#39;:&#39;nscf&#39;,
                              &#39;restart_mode&#39;:&#39;restart&#39;,&#39;smearing&#39;:&#39;tetrahedra&#39;,
                               &#39;verbosity&#39;:&#39;high&#39;})
calc.set(kpts=(16, 16, 16),
          input_data=input_data)
calc.calculate(atoms)</code></pre><p>とします。ここで、nscfはSCF計算をやらない、という意味です。そして、smearingのtetrahedraはDOS計算でよく使うものです。 kptsは運動量空間のk点の数で、これが多いほどDOSの精度が上がります。少なすぎるとピーキーな図になります。</p><p>次に、DOSの計算を行います。Quantum EspressoではDOS用の計算のコードにdos.xがあります。 ASEで対応していればいいのですが、今の所対応していないようなので、このdos.xを実行することにします。 dos.x用のインプットファイルはColabでは</p><pre><code class="language-python">%%bash
cat &lt;&lt;EOF &gt; espresso.dos.in
&amp;dos
   outdir = &#39;./&#39;,
   prefix=&#39;pwscf&#39;,
   fildos=&#39;espresso.dos&#39;,
   deltae =  0.1,
/
EOF</code></pre><p>とすれば作成できます。espresso.dos.inというファイル名の中身を、EOFとEOFの間に記述しています。 ここで、deltaeはDOSのスメアリングでこれを小さくすればするほどエネルギーの精度が上がりますが、 その分k点を増やさないとピーキーになります。dos.x自体の計算はすぐ終わりますので、このdeltaeを色々変えて絵がどうなるかをみてみると良いと思います。</p><p>これでファイルができました。</p><pre><code class="language-python">!cat espresso.dos.in</code></pre><p>で中身を確認できます。</p><p>dos.xの実行は</p><pre><code class="language-python">!dos.x &lt; espresso.dos.in &gt; espresso.dos.out</code></pre><p>でできます。 アウトプットはespresso.dos.outですので、中身の確認は</p><pre><code class="language-python">!cat espresso.dos.out</code></pre><p>でできます。あとはこれをプロットしてやるだけです。よくあるやり方でデータを読み込んでプロットしてみると、</p><pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
%config InlineBackend.figure_format = &#39;retina&#39;
ene,dos,integrateddos = np.loadtxt(&quot;./espresso.dos&quot;,unpack=True)
fig = plt.figure(figsize=(10, 6))
ax = fig.add_subplot(111)
ax.plot(ene, dos, color=&quot;k&quot;, label=&quot;DOS&quot;)
#ax.set_xlim(-1,1 )
ax.set_xlabel(&quot;E&quot;)
ax.set_ylabel(&quot;&quot;)
ax.legend(loc=&quot;upper left&quot;)
plt.show()</code></pre><p>得られたDOSは</p><p><img src="../SiDOS.png" alt="figSiDOS"/></p><p>となります。</p><p>DOSをもうすこし精度よく計算したい場合には、ブリルアンゾーン内の点の数を増やせばよいので、</p><pre><code class="language-python">nput_data.update({&#39;calculation&#39;:&#39;nscf&#39;,
                              &#39;restart_mode&#39;:&#39;restart&#39;,&#39;occupations&#39;:&#39;tetrahedra&#39;,
                               &#39;verbosity&#39;:&#39;low&#39;})
calc.set(kpts=(32, 32, 32),
          input_data=input_data)
calc.calculate(atoms)</code></pre><p>とkptsを増やせばよいです。 この時得られるDOSは</p><p>得られたDOSは</p><p><img src="../SiDOS_32.png" alt="figSiDOS_32"/></p><p>となります。</p><h1 id="部分DOSの計算"><a class="docs-heading-anchor" href="#部分DOSの計算">部分DOSの計算</a><a id="部分DOSの計算-1"></a><a class="docs-heading-anchor-permalink" href="#部分DOSの計算" title="Permalink"></a></h1><p>次に、軌道ごとのDOSを計算してみましょう。これも難しくありません。 軌道ごとのDOSを計算するには、projwfc.xを使います。</p><p>上ですでにDOSを計算していれば、projwfc.xのインプットファイルとして、</p><pre><code class="language-python">%%bash
cat &lt;&lt;EOF &gt; espresso.projwfc.in
&amp;projwfc
 prefix=&#39;pwscf&#39;
 outdir = &#39;./&#39;
 degauss = 0.01
/
EOF</code></pre><p>を作り、</p><pre><code class="language-python">!projwfc.x &lt; espresso.projwfc.in &gt; espresso.projwfc.out</code></pre><p>を実行するだけです。</p><p>Google Colabではなぜかファイル名のpwscf.pdos<em>atm#1(Si)</em>wfc#1(s)に&#39;がついてしまっているので、</p><pre><code class="language-python">!cat &#39;pwscf.pdos_atm#1(Si)_wfc#1(s)&#39; &gt; pwscf.pdos_atm1Si_wfc1s
!cat &#39;pwscf.pdos_atm#1(Si)_wfc#2(p)&#39; &gt; pwscf.pdos_atm1Si_wfc2p
!cat &#39;pwscf.pdos_atm#2(Si)_wfc#1(s)&#39; &gt; pwscf.pdos_atm2Si_wfc1s
!cat &#39;pwscf.pdos_atm#2(Si)_wfc#2(p)&#39; &gt; pwscf.pdos_atm2Si_wfc2p</code></pre><p>で抜いておきます。</p><p>あとはプロットするだけです。</p><pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
%matplotlib inline
%config InlineBackend.figure_format = &#39;retina&#39;
ene,totpdos1Si1s,s1 = np.loadtxt(&quot;./pwscf.pdos_atm1Si_wfc1s&quot;,unpack=True)
ene,totpdos1Si2p,px1,py1,pz1 = np.loadtxt(&quot;./pwscf.pdos_atm1Si_wfc2p&quot;,unpack=True)
ene,totpdos2Si1s,s2 = np.loadtxt(&quot;./pwscf.pdos_atm2Si_wfc1s&quot;,unpack=True)
ene,totpdos2Si2p,px2,py2,pz2 = np.loadtxt(&quot;./pwscf.pdos_atm2Si_wfc2p&quot;,unpack=True)
fig = plt.figure(figsize=(10, 6))
ax = fig.add_subplot(111)
ax.plot(ene, totpdos1Si1s,label=&quot;1Si1s&quot;)
ax.plot(ene, totpdos1Si2p,label=&quot;1Si2p&quot;)
ax.plot(ene, totpdos2Si1s,label=&quot;2Si1s&quot;)
ax.plot(ene, totpdos2Si2p,label=&quot;2Si2p&quot;)
#ax.set_xlim(-1,1 )
ax.set_xlabel(&quot;E&quot;)
ax.set_ylabel(&quot;&quot;)
ax.legend(loc=&quot;upper left&quot;)
plt.show()</code></pre><p>得られた部分DOSは</p><p><img src="../SiPDOS.png" alt="figSiPDOS"/></p><p>となります。</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../ASE/jupyter/">« Jupyter notebookの使用</a><a class="docs-footer-nextpage" href="../../QM/QM0/">Quantum Espresso »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Saturday 5 September 2020 23:07">Saturday 5 September 2020</span>. Using Julia version 1.5.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
